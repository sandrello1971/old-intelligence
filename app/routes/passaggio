from fastapi import APIRouter, UploadFile, File, HTTPException
from pydantic import BaseModel, validator
from openai import OpenAI
import os
import tempfile
import shutil
import time
from app.services.crmsdk import create_crm_activity
from app.core.database import get_db
from sqlalchemy.orm import Session
from app.services.crmsdk import create_crm_activity
from fastapi import Depends
from app.services.ulisse_activity_creator import create_ulisse_crm_activity


router = APIRouter(prefix="/ulisse/voice", tags=["ulisse"])

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
MODEL = os.getenv("OPENAI_MODEL", "gpt-4-turbo")


class TextInput(BaseModel):
    text: str

class ActivityInput(BaseModel):
    azienda: str
    servizi: list[str]
    priority: str  # Aggiunto per ricevere la priorità dall'input

    # Validazione della priorità
    @validator('priority')
    def validate_priority(cls, v):
        if v.lower() not in ["alta", "media", "bassa"]:
            raise ValueError('La priorità deve essere "alta", "media" o "bassa"')
        return v.lower()

    # Validazione dei servizi
    @validator('servizi')
    def validate_servizi(cls, v):
        if not v or len(v) == 0:
            raise ValueError('I servizi non possono essere vuoti.')
        return v

# Funzione per mappare la priorità
def map_priority(priority: str):
    priority_map = {
        "alta": 2,   # Alta = 2
        "media": 1,  # Media = 1
        "bassa": 0,  # Bassa = 0
    }
    return priority_map.get(priority, 0)  # Default a 0 se la priorità non è valida


# Funzione per gestire il delay in caso di errore 429
def delay_if_429(response):
    if response.status_code == 429:
        print("Errore 429: troppo traffico, attendo 5 secondi...")
        time.sleep(5)
        return True
    return False


@router.post("/transcribe")
def transcribe_audio(audio: UploadFile = File(...)):
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as tmp:
            shutil.copyfileobj(audio.file, tmp)
            tmp_path = tmp.name

        with open(tmp_path, "rb") as f:
            transcript = client.audio.transcriptions.create(
                model="whisper-1",
                file=f
            )
        os.remove(tmp_path)
        return {"text": transcript.text}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/extract")
def extract_entities(payload: TextInput):
    try:
        response = client.chat.completions.create(
            model=MODEL,
            messages=[
                {"role": "system", "content": "Estrai nome azienda e lista di servizi dal testo. Rispondi in JSON con 'azienda' e 'servizi'."},
                {"role": "user", "content": payload.text}
            ],
            temperature=0.2
        )
        content = response.choices[0].message.content
        data = eval(content) if isinstance(content, str) else content
        return data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/create_activity")
def create_ulisse_activity(data: ActivityInput, db: Session = Depends(get_db)):
    try:
        print(">>> Dati ricevuti dal frontend:")
        print("Azienda:", data.azienda)
        print("Servizi:", data.servizi)
        print("Priorità:", data.priority)

        # Dati dell'attività con la priorità mappata
        activity_data = {
            "customer_name": data.azienda,
            "description": ", ".join(data.servizi),
            "sub_type_id": 63705,
            "accompagnato_da_nome": "Barbara Romano",
            "accompagnato_da": "121796",
            "priority": map_priority(data.priority),  # Mappiamo la priorità da input
        }

        print(">>> Activity data pronto per il CRM:", activity_data)

        # Creazione attività nel CRM
        response = create_crm_activity(activity_data)
        
        # Gestiamo l'errore 429 con il delay se necessario
        if delay_if_429(response):
            response = create_crm_activity(activity_data)

        new_id = response.get("id")
        print(">>> Nuova attività CRM ID:", new_id)

        # Sincronizzazione dell'attività nel DB
        sync_single_activity(new_id, db)
        return {"id": new_id}
    
    except Exception as e:
        print(">>> ERRORE nella creazione attività:", str(e)) 
        raise HTTPException(status_code=500, detail=str(e))
