
from fastapi import APIRouter, UploadFile, File, HTTPException, Depends, Header
from pydantic import BaseModel, validator
from openai import OpenAI
import os
import tempfile
import shutil
import json
import mimetypes
import re
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from integrations.crm_incloud.sync import sync_single_activity
from app.services.crmsdk import create_crm_activity, get_company_id_by_name
from app.core.database import get_db
from typing import Optional
from app.models import User
from app.auth.google import get_current_user
from app.models.owner import Owner

router = APIRouter(prefix="/ulisse/voice", tags=["ulisse"])

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
MODEL = os.getenv("OPENAI_MODEL", "gpt-4-turbo")


class TextInput(BaseModel):
    text: str


class ActivityInput(BaseModel):
    azienda: str
    servizi: list[str]
    priority: str = "bassa"
    transcript: Optional[str] = ""

    @validator("priority")
    def validate_priority(cls, v):
        if v.lower() not in ["alta", "media", "bassa"]:
            raise ValueError('La priorit√† deve essere "alta", "media" o "bassa"')
        return v.lower()

    @validator("servizi")
    def validate_servizi(cls, v):
        if not v or len(v) == 0:
            raise ValueError("I servizi non possono essere vuoti.")
        return v


def map_priority(priority: str):
    return {"alta": 2, "media": 1, "bassa": 0}.get(priority, 0)


@router.post("/transcribe")
def transcribe_audio(audio: UploadFile = File(...)):
    try:
        content_type = audio.content_type or "application/octet-stream"
        extension = mimetypes.guess_extension(content_type) or ".webm"

        with tempfile.NamedTemporaryFile(delete=False, suffix=extension) as tmp:
            shutil.copyfileobj(audio.file, tmp)
            tmp_path = tmp.name
        print(f"üßæ Content-Type ricevuto: {content_type}")
        print(f"üì¶ Estensione dedotta: {extension}")
        print(f"üìÅ File temporaneo: {tmp_path}")
        with open(tmp_path, "rb") as f:
            transcript = client.audio.transcriptions.create(
            model="whisper-1",
                file=("recording.webm", f, "audio/webm")
            )


        os.remove(tmp_path)
        return {"text": transcript.text}
    except Exception as e:
        import traceback
        traceback.print_exc() 
        raise HTTPException(status_code=500, detail=f"Errore trascrizione audio: {e}")


@router.post("/extract")
def extract_entities(payload: TextInput):
    print("üìù Testo da analizzare:", payload.text)

    try:
        response = client.chat.completions.create(
            model=MODEL,
            messages=[
                {
                    "role": "system",
                    "content": "Estrai nome azienda e lista di servizi dal testo. Rispondi in JSON con 'azienda' e 'servizi'. I servizi devono essere normalizzati nei seguenti valori standard, anche in presenza di errori di ortografia o sinonimi: 'Formazione 4.0', 'Patent Box', 'Credito d‚ÄôImposta', ecc."
                },
                {"role": "user", "content": payload.text}
            ],
            temperature=0.2
        )

        content = response.choices[0].message.content.strip()
        print("üß† Risposta GPT:", content)

        if content.startswith("```"):
            content = re.sub(r"^```[a-z]*\n?", "", content, flags=re.IGNORECASE)
            content = content.rstrip("```").strip()

        try:
            data = json.loads(content) if isinstance(content, str) else content
        except Exception as parse_err:
            print("‚ùå Errore parsing JSON:", parse_err)
            raise HTTPException(status_code=500, detail="Risposta GPT non √® JSON valido")

        if not isinstance(data, dict) or not data.get("azienda") or not isinstance(data.get("servizi"), list) or not data["servizi"]:
            raise HTTPException(status_code=422, detail="Estrazione non valida: assicurati di menzionare azienda e almeno un servizio.")

        return data

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore estrazione entit√†: {e}")


@router.post("/create_activity")
def create_ulisse_activity(
    data: ActivityInput,
    db: Session = Depends(get_db),
    owner: Owner = Depends(get_current_user)
):
    try:
        from pprint import pprint
        pprint(data.dict())

        company_id = get_company_id_by_name(data.azienda, db)
        if not company_id:
            raise HTTPException(status_code=404, detail="Azienda non trovata")

        activity_data = {
            "idCompanion": 120385,
            "subTypeId": 63705,
            "description": f"{data.transcript}\n\n---\n\n{', '.join(data.servizi)}",
            "ownerId": owner.id,
            "companyId": company_id,
            "priority": map_priority(data.priority),
            "subject": f"Incarico 24 Mesi - {data.azienda}",
            "customer_name": data.azienda,
            "type": 7,
            "activityDate": datetime.utcnow().isoformat() + "Z",
            "activityEndDate": (datetime.utcnow() + timedelta(days=1)).isoformat() + "Z",
        }

        response = create_crm_activity(activity_data)
        sync_single_activity(response, db)
        return {"id": response}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore creazione attivit√†: {e}")


print("‚úÖ ulisse_voice router loaded")
